# -*- coding: utf-8 -*-
"""ChemicalStructureDetection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uDug6-hMTc9X7qYNcD2gA2byO0gQiC6p
"""
'''
!pip install paddleocr
!pip install paddlepaddle==2.0.0 -i https://mirror.baidu.com/pypi/simple

from google.colab import drive
drive.mount('/content/drive')

!rm -f data
!ln -s '/content/drive/MyDrive/Retrosynthesis/OCR/chem-struct' data
'''
from rdkit.Chem import AllChem as Chem
from paddleocr import PaddleOCR
import cv2
import numpy as np
import os
import matplotlib.pyplot as plt

os.chdir('/home/tlta/Desktop/Workdir/ReactionScheme/Structure/Picture/')

def scale(color_img, width=600):
    h, w, c = color_img.shape
    ratio = width/w
    return cv2.resize(color_img, (width, int(h*ratio)))

# PaddleOCR
pocr = PaddleOCR(lang='en')

for img_name in os.listdir('.'):
    ## detect characters
    if '*' in img_name:
        continue
    image = scale(cv2.imread(img_name))
    result = pocr.ocr(image)
    # for line in result:
    #     print(line)
    
    ## not yet detect all of chars/words in the figure
    ## can use template matching to remove them: C, N, O, S, P
    img_to_show = image.copy()
    for i, (box, text) in enumerate(result):    # if combine with Tesseract to get details, add code here
        pts = np.array(box, np.int32)
        point_to_write = tuple(pts[0])
        pts = pts.reshape((-1,1,2))
        img_to_show = cv2.polylines(img_to_show, [pts], True, (0,0,255), 2)
        # font = cv2.FONT_HERSHEY_SIMPLEX
        # img = cv2.putText(img, f'{i}', point_to_write, font, 0.5, (0,0,255), 1, cv2.LINE_AA)

    plt.imshow(img_to_show)
    plt.axis('off')
    plt.show()


    ## remove those characters, i.e draw a white filled rectangle
    for box, text in result:
        pts = np.array(box, np.int32)
        cv2.fillPoly(image, [pts], (255,255,255))

    plt.imshow(image)
    plt.axis('off')
    plt.show()


    ## begin to detect edges, vertices
    img = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
    # binarize: < 225 -> down 0 -> invert to 255
    img = cv2.threshold(img, 200, 255, cv2.THRESH_BINARY_INV)[1] # thresh need to be tuned
    no_of_vertices = 0
    #cv2.threshold()

    plt.imshow(img, cmap='gray')
    plt.axis('off')


    ## find contours, then based on that to detect the shape
    (cnts, _) = cv2.findContours(img, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)   # cv2.RETR_EXTERNAL
    for c in cnts: 
        ## approximate contour by polygon
        peri = cv2.arcLength(c, True)
        area = cv2.contourArea(c)

        ## check some conditions to remove unwanted parts
        if peri < 50 or area < 30: # corresponding to width=600
            continue
        approx = cv2.approxPolyDP(c, 8, True) # 8 for width=600, 5 for width=400
        no_of_vertices += len(approx)

        # print(  'Area', area, 
        #         ',\t Peri', peri,
        #         ',\t #vertices', len(approx)) # so, not yet done at this step

        ## draw contour
        cv2.drawContours(image, [approx], -1, (0,255,0), 2)
    
    plt.imshow(image)
    plt.axis('off')
    plt.show()

    ##Get bond conut
    SMILES = img_name.split('.')[0]
    mol = Chem.MolFromSmiles(SMILES)

    cnt = 0
    try:
        bonds = mol.GetBonds()
        for bond in bonds:
            bond_type = str(bond.GetBondType())
            #print(bond_type)
            if bond_type == "SINGLE":
                cnt += 1
            elif bond_type == 'AROMATIC':
                cnt += 1.5
            elif bond_type == "DOUBLE" :
                cnt += 2
            elif bond_type == "TRIPLE":
                cnt += 3
	## summarize info
        print(SMILES, ', bond count:', int(cnt), ', Number of line: ', no_of_vertices//2, '\n')
    except:
        print('Something wrong when getting bond count')
	print(SMILES, ', Number of line: ', no_of_vertices//2, '\n')
"""Todo:
- Expand the boxes detected by PaddleOCR to better erase chars
- Use template matching to deal with some remain char, e.g O, S, N, C, P, ..
- Apply rule-based code to refine approximated contours (merge two near points to one)
"""
